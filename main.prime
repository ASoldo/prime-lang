module app::main;

import core::types;

const TRAINING_LIMIT: int32 = 3;

interface Renderable[T] {
  fn render(self: T);
}

interface Nameable[T] {
  fn label(self: T) -> string;
}

struct PlayerPanel {
  label: string;
  position: Vec2;
  velocity: Vec2;
  hp: int32;
  stamina: int32;
  level: int32;
}

struct EnemyPanel {
  label: string;
  position: Vec2;
  velocity: Vec2;
  attack: Damage;
}

struct QuestPanel {
  label: string;
  reward: int32;
  completed: bool;
}

impl Renderable[PlayerPanel] for PlayerPanel {
  fn render(panel: PlayerPanel) {
    let mut string status = "ready";
    if panel.hp < 50 {
      status = "fragile";
    }
    out("----- player -----");
    out(`label: {}`, panel.label);
    out(`pos: ({}, {})`, panel.position.x, panel.position.y);
    out(`hp/stamina: {} / {}`, panel.hp, panel.stamina);
    out(`level: {}`, panel.level);
    out(`status: {status}`);
  }
}

impl Nameable[PlayerPanel] for PlayerPanel {
  fn label(panel: PlayerPanel) -> string {
    panel.label
  }
}

impl Renderable[EnemyPanel] for EnemyPanel {
  fn render(panel: EnemyPanel) {
    out("--- enemy ---");
    out(`label: {}`, panel.label);
    out(`pos: ({}, {})`, panel.position.x, panel.position.y);
  }
}

impl Nameable[EnemyPanel] for EnemyPanel {
  fn label(panel: EnemyPanel) -> string {
    panel.label
  }
}

impl Renderable[QuestPanel] for QuestPanel {
  fn render(panel: QuestPanel) {
    out("--- quest ---");
    out(`label: {}`, panel.label);
    out(`reward: {}`, panel.reward);
    let string state = if panel.completed {
      "completed"
    } else {
      "in progress"
    };
    out(`state: {state}`);
  }
}

impl Nameable[QuestPanel] for QuestPanel {
  fn label(panel: QuestPanel) -> string {
    panel.label
  }
}

fn player_panel(p: Player) -> PlayerPanel {
  PlayerPanel{
    p.name,
    p.position,
    p.velocity,
    p.hp,
    p.stamina,
    p.level,
  }
}

fn enemy_panel(e: Enemy) -> EnemyPanel {
  EnemyPanel{
    e.kind,
    e.position,
    e.velocity,
    e.attack,
  }
}

fn quest_panel(q: Quest) -> QuestPanel {
  QuestPanel{
    q.title,
    q.reward,
    q.completed,
  }
}

fn calibrate_station(name: string) {
  out(`Calibrating station: {name}`);
  defer out("Station teardown complete");
  let mut int32 probes = 0;
  while probes < 2 {
    out(`probe step {probes}`);
    probes = probes + 1;
  }
}

fn main() {
  out("=== prime-lang gameplay demo ===");
  let mut Player hero = spawn_player("Prime Hero", Vec2{ 10.0, 20.0 }, 120);
  let Player scout = spawn_player("Sparrow", Vec2{ 5.0, 12.5 }, 90);
  player_panel(hero).render();
  player_panel(scout).render();
  out("Roster labels:");
  out(`- {}`, player_panel(hero).label());
  out(`- {}`, player_panel(scout).label());
  let Player relocated = move_player(hero, Vec2{ 2.0, 3.0 });
  out("After repositioning:");
  player_panel(relocated).render();
  let Player wounded = apply_damage(relocated, Flat(30));
  out("Hero after heavy hit:");
  player_panel(wounded).render();
  let Player healed = drink_potion(wounded, 24);
  out("Hero after potion:");
  player_panel(healed).render();
  let Player leveled = level_up(healed, 2);
  out("Hero after leveling:");
  player_panel(leveled).render();
  let Player mission_ready = heal(leveled, 8);
  out("Hero after single-step heal:");
  player_panel(mission_ready).render();
  let Enemy brute = spawn_enemy("Emerald brute", Vec2{ 18.0, 24.0 }, Percent(15));
  enemy_panel(brute).render();
  let Quest quest = Quest{
    "Defend the valley",
    450,
    false,
  };
  out(`Quest focus: {}`, quest_panel(quest).label());
  quest_panel(quest).render();
  out("Encounter simulation:");
  run_encounter(mission_ready, scout, brute);
  out("Training countdown:");
  countdown(TRAINING_LIMIT);
  simulate_patrol("River path", 4);
  let int32 borrowed_hp = peek_hp(&hero);
  out(`Borrowed hero hp: {borrowed_hp}`);
  let bool hero_ready = hero.hp > 100 && hero.stamina >= 50;
  let bool scout_ready = scout.hp > 70 && scout.stamina >= 40;
  out(`Hero battle ready? {hero_ready}`);
  out(`Scout battle ready? {scout_ready}`);
  let MissionEvent ridge = plan_mission("Prime ascent", true, true);
  let MissionEvent harbor = plan_mission("Harbor sweep", false, true);
  describe_event(ridge);
  describe_event(harbor);
  let string pending = summarize_event(Waiting());
  out(`Mission summary hint: {pending}`);
  let Option[int32] slot = find_training_slot(TRAINING_LIMIT);
  match slot {
    Some(value) => {
      out(`Training slot assigned: {value}`);
    },
    None => {
      out("Training slots unavailable");
    },
  }
  let Option[int32] backup_slot = find_training_slot(TRAINING_LIMIT + 1);
  match backup_slot {
    Some(value) => {
      out(`Training slot now available: {value}`);
    },
    None => {
      out("Backup training slots unavailable");
    },
  }
  match resolve_attack(mission_ready, brute.attack) {
    Ok(survivor) => {
      out("Hero resisted the heavy blow:");
      player_panel(survivor).render();
    },
    Err(msg) => {
      out(`Hero staggered: {msg}`);
    },
  }
  match resolve_attack(mission_ready, Percent(25)) {
    Ok(survivor) => {
      out("Hero shrugged off the assault:");
      player_panel(survivor).render();
    },
    Err(msg) => {
      out(`Hero staggered under the assault: {msg}`);
    },
  }
  refill_hp(&mut hero, 12);
  out("Hero after field medic response:");
  player_panel(hero).render();
  calibrate_station("Signal tower");
  out("Defer order check:");
  test_defer_order();
  let divmod_result = divmod(22, TRAINING_LIMIT);
  out(`divmod(22, TRAINING_LIMIT): {}`, divmod_result);
  announce_session("Session complete");
}

fn spawn_player(name: string, position: Vec2, hp: int32) -> Player {
  Player{
    Transform{
      position,
      Vec2{
        0.0,
        0.0,
      },
    },
    Stats{
      hp,
      hp / 2,
    },
    name,
    1,
  }
}

fn spawn_enemy(kind: string, position: Vec2, attack: Damage) -> Enemy {
  Enemy{
    Transform{
      position,
      Vec2{
        0.0,
        0.0,
      },
    },
    kind,
    attack,
  }
}

fn move_player(p: Player, offset: Vec2) -> Player {
  let Vec2 next = add_vec2(p.position, offset);
  Player{
    Transform{
      next,
      p.velocity,
    },
    Stats{
      p.hp,
      p.stamina,
    },
    p.name,
    p.level,
  }
}

fn add_vec2(a: Vec2, b: Vec2) -> Vec2 {
  Vec2{
    a.x + b.x,
    a.y + b.y,
  }
}

fn apply_damage(p: Player, damage: Damage) -> Player {
  match damage {
    Flat(amount) =>     Player{
      Transform{
        p.position,
        p.velocity,
      },
      Stats{
        p.hp - amount,
        p.stamina,
      },
      p.name,
      p.level,
    },
    Percent(percent) => {
      let int32 scaled = p.hp * percent / 100;
      Player{
        Transform{
          p.position,
          p.velocity,
        },
        Stats{
          p.hp - scaled,
          p.stamina,
        },
        p.name,
        p.level,
      }
    },
  }
}

fn drink_potion(p: Player, heal: int32) -> Player {
  let int32 boosted = p.hp + heal;
  Player{
    Transform{
      p.position,
      p.velocity,
    },
    Stats{
      boosted,
      p.stamina + heal / 2,
    },
    p.name,
    p.level,
  }
}

fn level_up(p: Player, levels: int32) -> Player {
  let int32 bonus = levels * 5;
  Player{
    Transform{
      p.position,
      p.velocity,
    },
    Stats{
      p.hp + bonus,
      p.stamina + bonus,
    },
    p.name,
    p.level + levels,
  }
}

fn announce_session(message: string) {
  out(`--- session log --- {message}`);
}

fn run_encounter(hero: Player, ally: Player, enemy: Enemy) {
  let mut int32 round = 0;
  let mut Player current = hero;
  while round < 3 {
    out(`round {round}`);
    current = apply_damage(current, enemy.attack);
    round = round + 1;
  }
  out("Post-encounter hero:");
  player_panel(current).render();
  out("Ally remained ready:");
  player_panel(ally).render();
}

fn countdown(limit: int32) {
  let mut int32 step = 0;
  while step < limit {
    out(`countdown step {step}`);
    step = step + 1;
  }
}

fn simulate_patrol(name: string, steps: int32) {
  out(`--- patrol start: {name} ---`);
  for i in 0..steps {
    out(`step {i}`);
  }
  out("--- patrol complete ---");
}

fn find_training_slot(day: int32) -> Option[int32] {
  if day % 2 == 0 {
    Some(day)
  } else {
    None()
  }
}

fn resolve_attack(hero: Player, damage: Damage) -> Result[Player, string] {
  let Player updated =   match damage {
    Flat(amount) => apply_damage(hero, Flat(amount)),
    Percent(percent) => {
      if percent < 20 {
        apply_damage(hero, Percent(percent))
      } else {
        return Err("impact too high");
      }
    },
  };
  Ok(updated)
}

fn peek_hp(target: &Player) -> int32 {
  let Player snapshot = *target;
  snapshot.hp
}

fn refill_hp(target: &mut Player, amount: int32) {
  let Player snapshot = *target;
  let Player refreshed = Player{
    Transform{ snapshot.position, snapshot.velocity },
    Stats{ snapshot.hp + amount, snapshot.stamina },
    snapshot.name,
    snapshot.level,
  };
  *target = refreshed;
}

fn plan_mission(name: string, ready: bool, slots_open: bool) -> MissionEvent {
  if ready {
    Completed(name)
  } else {
    if slots_open {
      Failed("requires tide shift")
    } else {
      Waiting()
    }
  }
}

fn describe_event(event: MissionEvent) {
  match event {
    Completed(stage) if stage == "Prime ascent" => {
      out(`mission completed with honors: {stage}`);
    },
    Completed(stage) => {
      out(`mission completed: {stage}`);
    },
    Failed(reason) => {
      out(`mission failed: {reason}`);
    },
    MissionEvent::Waiting => {
      out("mission awaiting clearance");
    },
  }
}

fn summarize_event(event: MissionEvent) -> string {
  match event {
    Completed(stage) => stage,
    Failed(reason) => reason,
    MissionEvent::Waiting => "Awaiting assignment",
  }
}

fn divmod(a: int32, b: int32) -> (int32, int32) {
  let int32 q = a / b;
  let int32 r = a % b;
  (q, r)
}

fn heal(player: Player, boost: int32) -> Player {
  Player{
    Transform{
      player.position,
      player.velocity,
    },
    Stats{
      player.hp + boost,
      player.stamina,
    },
    player.name,
    player.level,
  }
}

fn test_defer_order() {
  out("arming defers");
  defer out("first");
  defer out("middle");
  defer out("last");
}
