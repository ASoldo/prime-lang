import "types";

const TRAINING_LIMIT: int32 = 3;

fn main() {
  out("=== prime-lang gameplay demo ===");
  let mut Player hero = spawn_player("Prime Hero", Vec2{ 10.0, 20.0 }, 120);
  out("=== heal() ===");
  let Player scout = spawn_player("Sparrow", Vec2{ 5.0, 12.5 }, 90);
  describe_player(hero);
  describe_player(scout);
  let Player relocated = move_player(hero, Vec2{ 2.0, 3.0 });
  out("After repositioning:");
  describe_player(relocated);
  let Player wounded = apply_damage(relocated, Flat(30));
  out("Hero after heavy hit:");
  describe_player(wounded);
  let Player healed = drink_potion(wounded, 24);
  out("Hero after potion:");
  describe_player(healed);
  let Player leveled = level_up(healed, 2);
  out("Hero after leveling:");
  describe_player(leveled);
  let Enemy brute = spawn_enemy("Emerald brute", Vec2{ 18.0, 24.0 }, Percent(15));
  describe_enemy(brute);
  let Quest quest = Quest{
    "Defend the valley",
    450,
    false,
  };

  describe_quest(quest);
  out("Encounter simulation:");
  run_encounter(leveled, scout, brute);
  out("Training countdown:");
  countdown(TRAINING_LIMIT);
  simulate_patrol("River path", 4);
  let int32 borrowed_hp = peek_hp(&hero);
  out("Borrowed hero hp:");
  out(borrowed_hp);
  let MissionEvent ridge = plan_mission("Ridge scouting", true, true);
  let MissionEvent harbor = plan_mission("Harbor sweep", false, true);
  describe_event(ridge);
  describe_event(harbor);
  let string pending = summarize_event(Waiting());
  out("Mission summary hint:");
  out(pending);
  let Option[int32] slot = find_training_slot(TRAINING_LIMIT);
  match slot {
    Some(value) => {
      out("Training slot assigned:");
      out(value);
    },
    None => {
      out("Training slots unavailable");
    },
  };
  match resolve_attack(leveled, brute.attack) {
    Ok(survivor) => {
      out("Hero resisted the heavy blow:");
      describe_player(survivor);
    },
    Err(msg) => {
      out("Hero staggered:");
      out(msg);
    },
  };
  refill_hp(&mut hero, 12);
  out("Hero after field medic response:");
  describe_player(hero);
  calibrate_station("Signal tower");
  let divmod_result = divmod(22, TRAINING_LIMIT);
  out("divmod(22, TRAINING_LIMIT):");
  out(divmod_result);
  announce_session("Session complete");
}

fn spawn_player(name: string, position: Vec2, hp: int32) -> Player {
  Player{
    Transform{
      position,
      Vec2{
        0.0,
        0.0,
      },
    },
    Stats{
      hp,
      hp / 2,
    },
    name,
    1,
  }
}

fn spawn_enemy(kind: string, position: Vec2, attack: Damage) -> Enemy {
  Enemy{
    Transform{
      position,
      Vec2{
        0.0,
        0.0,
      },
    },
    kind,
    attack,
  }
}

fn describe_player(p: Player) {
  out("----- player -----");
  out(p.name);
  out(p.position.x);
  out(p.position.y);
  out(p.hp);
  out(p.stamina);
  if p.hp < 50 {
    out("status: fragile");
  } else {
    out("status: ready");
  }
}

fn describe_enemy(enemy: Enemy) {
  out("--- enemy ---");
  out(enemy.kind);
  out(enemy.position.x);
  out(enemy.position.y);
  describe_damage(enemy.attack);
}

fn describe_damage(damage: Damage) {
  match damage {
    Flat(amount) => {
      out("attack: flat");
      out(amount);
    },
    Percent(rate) => {
      out("attack: percent");
      out(rate);
    },
  }
}

fn describe_quest(quest: Quest) {
  out("--- quest ---");
  out(quest.title);
  out(quest.reward);
  if quest.completed {
    out("state: completed");
  } else {
    out("state: in progress");
  }
}

fn move_player(p: Player, offset: Vec2) -> Player {
  let Vec2 next = add_vec2(p.position, offset);
  Player{
    Transform{
      next,
      p.velocity,
    },
    Stats{
      p.hp,
      p.stamina,
    },
    p.name,
    p.level,
  }
}

fn add_vec2(a: Vec2, b: Vec2) -> Vec2 {
  Vec2{
    a.x + b.x,
    a.y + b.y,
  }
}

fn apply_damage(p: Player, damage: Damage) -> Player {
  match damage {
    Flat(amount) =>     Player{
      Transform{
        p.position,
        p.velocity,
      },
      Stats{
        p.hp - amount,
        p.stamina,
      },
      p.name,
      p.level,
    },
    Percent(percent) => {
      let int32 scaled = p.hp * percent / 100;
      Player{
        Transform{
          p.position,
          p.velocity,
        },
        Stats{
          p.hp - scaled,
          p.stamina,
        },
        p.name,
        p.level,
      }
    },
  }
}

fn drink_potion(p: Player, heal: int32) -> Player {
  let int32 boosted = p.hp + heal;
  Player{
    Transform{
      p.position,
      p.velocity,
    },
    Stats{
      boosted,
      p.stamina + heal / 2,
    },
    p.name,
    p.level,
  }
}

fn level_up(p: Player, levels: int32) -> Player {
  let int32 bonus = levels * 5;
  Player{
    Transform{
      p.position,
      p.velocity,
    },
    Stats{
      p.hp + bonus,
      p.stamina + bonus,
    },
    p.name,
    p.level + levels,
  }
}

fn announce_session(message: string) {
  out("--- session log ---");
  out(message);
}

fn run_encounter(hero: Player, ally: Player, enemy: Enemy) {
  let mut int32 round = 0;
  let mut Player current = hero;
  while round < 3 {
    out("round");
    out(round);
    current = apply_damage(current, enemy.attack);
    round = round + 1;
  }
  out("Post-encounter hero:");
  describe_player(current);
  out("Ally remained ready:");
  describe_player(ally);
}

fn countdown(limit: int32) {
  let mut int32 step = 0;
  while step < limit {
    out(step);
    step = step + 1;
  }
}

fn simulate_patrol(name: string, steps: int32) {
  out("--- patrol start ---");
  out(name);
  for i in 0..steps {
    out("step");
    out(i);
  }
  out("--- patrol complete ---");
}

fn find_training_slot(day: int32) -> Option[int32] {
  if day % 2 == 0 {
    Some(day)
  } else {
    None()
  }
}

fn resolve_attack(hero: Player, damage: Damage) -> Result[Player, string] {
  match damage {
    Flat(amount) => Ok(apply_damage(hero, Flat(amount))),
    Percent(percent) => {
      if percent < 20 {
        Ok(apply_damage(hero, Percent(percent)))
      } else {
        Err("impact too high")
      }
    },
  }
}

fn peek_hp(target: &Player) -> int32 {
  let Player snapshot = *target;
  snapshot.hp
}

fn refill_hp(target: &mut Player, amount: int32) {
  let Player snapshot = *target;
  let Player refreshed = Player{
    Transform{ snapshot.position, snapshot.velocity },
    Stats{ snapshot.hp + amount, snapshot.stamina },
    snapshot.name,
    snapshot.level,
  };

  *target = refreshed;
}

fn plan_mission(name: string, ready: bool, slots_open: bool) -> MissionEvent {
  if ready {
    Completed(name)
  } else {
    if slots_open {
      Failed("requires tide shift")
    } else {
      Waiting()
    }
  }
}

fn describe_event(event: MissionEvent) {
  match event {
    Completed(stage) => {
      out("mission completed:");
      out(stage);
    },
    Failed(reason) => {
      out("mission failed:");
      out(reason);
    },
    Waiting => {
      out("mission awaiting clearance");
    },
  }
}

fn summarize_event(event: MissionEvent) -> string {
  match event {
    Completed(stage) => stage,
    Failed(reason) => reason,
    Waiting => "Awaiting assignment",
  }
}

fn calibrate_station(name: string) {
  out("Calibrating station:");
  out(name);
  defer out("Station teardown complete");
  let mut int32 probes = 0;
  while probes < 2 {
    out("probe");
    out(probes);
    probes = probes + 1;
  }
}

fn divmod(a: int32, b: int32) -> (int32, int32) {
  let int32 q = a / b;
  let int32 r = a % b;
  (q, r)
}

fn heal(player: Player, boost: int32) -> Player {
  Player{
    Transform{
      player.position,
      player.velocity,
    },
    Stats{
      player.hp + boost,
      player.stamina,
    },
    player.name,
    player.level,
  }
}
