//! Drop semantics tests.
//!
//! Validates `Drop` runs exactly once, at the correct time, and interacts
//! correctly with `defer`.
test tests::drop;

import core::types;

/// Records its own drops into a shared log slice.
struct Tracker {
  label: string;
  log: &mut []string;
}

/// `Drop` impl used by the tests below.
impl Drop for Tracker {
  fn drop(self: &mut Tracker) {
    self.log.push(self.label);
  }
}

/// Ensures values are dropped when leaving a scope.
fn drop_runs_on_scope_exit() -> bool {
  let mut []string log = [];
  {
    let Tracker tracker = Tracker { label: "alpha", log: &mut log };
    out(tracker.label);
  }
  match log[0] {
    Some(value) => log.len() == 1 && value == "alpha",
    None => false,
  }
}

/// Ensures `defer` runs between inner drops in LIFO order.
fn drop_orders_with_defer() -> bool {
  let mut []string log = [];
  {
    let Tracker first = Tracker { label: "first", log: &mut log };
    defer log.push("defer");
    let Tracker second = Tracker { label: "second", log: &mut log };
    out(first.label);
    out(second.label);
  }
  match (log[0], log[1], log[2]) {
    (Some(a), Some(b), Some(c)) => a == "second" && b == "defer" && c == "first",
    _ => false,
  }
}

/// Ensures a moved-out value is dropped once after its last use.
fn drop_occurs_once_after_last_use() -> bool {
  let mut []string log = [];
  {
    let Box[Tracker] owner = box_new(Tracker { label: "single", log: &mut log });
    let Tracker shadow = owner.box_take();
    out(shadow.label);
  }
  match log[0] {
    Some(value) => log.len() == 1 && value == "single",
    None => false,
  }
}
