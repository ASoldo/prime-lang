//! Basic language regression tests.
//!
//! Covers arithmetic, imports, pointers, ranges, iterables, safe indexing,
//! assignment-through-index, block expressions, and `defer`.
test tests::basic;

import pkg::lib::{banner, promote, describe};
import core::types;

/// Returns a tuple to validate multi-value returns.
fn adds_numbers() -> (int32, int32) {
  (1, 4)
}

/// Verifies arithmetic and boolean return from a test function.
fn adds_two_numbers(a: int32, b: int32) -> bool {
  a + b == 5
}

/// Ensures imported types and functions from `pkg::lib` work correctly.
fn validates_imported_identity() -> bool {
  let Banner b = promote("task", true);
  let string status = describe(b);
  status == "highlighted"
}

/// Exercises `assert`, `expect`, and common string helpers.
fn uses_asserts() -> bool {
  assert(true);
  expect(true, "expect should not panic");
  let string sentence = `one two three`;
  let int32 chars = sentence.str_len();
  let bool has_two = sentence.str_contains("two");
  let string trimmed = ` padded `.str_trim();
  let []string parts = sentence.str_split(" ");
  return chars == 13 && has_two && trimmed == "padded" && parts.len() == 3;
}

/// Writes through a raw pointer returned by `ptr_mut`.
fn pointer_writes() -> bool {
  let mut int32 hp = 10;
  let ptr = ptr_mut(&mut hp);
  *ptr = *ptr + 5;
  hp == 15 && *ptr == 15
}

/// Reads through a raw pointer returned by `ptr`.
fn pointer_reads() -> bool {
  let int32 hp = 7;
  let ptr = ptr(&hp);
  *ptr == 7
}

/// Validates that ranges can be stored as values.
fn range_is_storable() -> bool {
  let Range[int32] span = 1..=3;
  span;
  true
}

/// Validates that `for` can iterate over a stored range.
fn iterates_stored_range() -> bool {
  let Range[int32] span = 1..3;
  let mut int32 total = 0;
  for value in span {
    total = total + value;
  }
  total == 3
}

/// Minimal custom iterable type used for `for value in counter`.
struct Counter {
  data: []int32;
}

impl Iterable[int32] for Counter {
  /// Returns the backing slice for iteration.
  fn iter(counter: Counter) -> []int32 {
    counter.data
  }
}

/// Validates `Iterable` + `for` loop integration.
fn iterates_custom_iterable() -> bool {
  let Counter counter = Counter{
    data: [4, 5],
  };
  let mut int32 total = 0;
  for value in counter {
    total = total + value;
  }
  total == 9
}

/// Validates safe indexing into slices returns `Option`.
fn indexes_slice() -> bool {
  let []int32 values = [
    10,
    20,
  ];
  match values[1] {
    Some(found) => found == 20,
    None => false,
  }
}

/// Validates safe indexing into maps returns `Option`.
fn indexes_map_literal() -> bool {
  let Map[string, int32] rewards = #{
    "Alpha": 3,
  };
  match rewards["Alpha"] {
    Some(found) => found == 3,
    None => false,
  }
}

/// Validates out-of-bounds indexes return `None` (no panic).
fn index_bounds_are_safe() -> bool {
  let []string empty = [];
  match empty[0] {
    Some(_) => false,
    None => true,
  }
}

/// Validates index assignment updates an existing slice entry.
fn index_assignment_updates_slice() -> bool {
  let []int32 numbers = [
    1,
    2,
    3,
  ];
  numbers[1] = 42;
  match numbers[1] {
    Some(found) => found == 42,
    None => false,
  }
}

/// Validates index assignment inserts a new key into a map.
fn index_assignment_inserts_map() -> bool {
  let Map[string, int32] counts = #{
    "hp": 5,
  };
  counts["mp"] = 7;
  match counts["mp"] {
    Some(found) => found == 7,
    None => false,
  }
}

/// Validates that block expressions can mutate an outer variable.
fn closure_mut_ref_capture_mutates() -> bool {
  let mut int32 hp = 10;
  let int32 after = {
    hp = hp + 5;
    hp
  };
  hp == 15 && after == 15
}

/// Validates `defer` runs when leaving a scope.
fn closure_defer_runs() -> bool {
  let mut []int32 log = [];
  {
    defer log.push(2);
    log.push(1);
  }
  match log[1] {
    Some(v) => log.len() == 2 && v == 2,
    None => false,
  }
}
