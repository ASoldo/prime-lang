module demos::no_std_parity;

// Local enums so we don't depend on std libs in no_std.
pub enum Option[T] {
  Some(T),
  None,
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

// Simple defer test (no heap).
fn defer_probe() {
  let mut int32 guard = 0;
  defer {
    guard = guard + 1;
    out(`defer ran guard={guard}`);
  };
  out(`defer probe start guard={guard}`);
}

fn async_result_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v + 1,
      Option::None => -1,
    }
  };
  let _ = send(tx, 5);
  close(tx);
  let _ = join(worker);
  out("async result parity joined");
}

fn async_try_parity() {
  let (tx, rx) = channel[Result[int32, string]]();
  let worker = spawn async {
    let Option[Result[int32, string]] received = await recv_task(rx);
    match received {
      Option::Some(Result::Ok(v)) => Result::Ok(v + 2),
      Option::Some(Result::Err(msg)) => Result::Err(msg),
      Option::None => Result::Err("empty"),
    }
  };
  let _ = send(tx, Result::Ok(7));
  close(tx);
  let joined = join(worker);
  match joined {
    Result::Ok(v) => out(`async try parity ok {v}`),
    Result::Err(msg) => out(`async try parity err {msg}`),
    Option::Some(v) => out(`async try parity some {v}`),
    Option::None => out("async try parity none"),
    _ => out("async try parity other"),
  }
}

fn timeout_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v,
      Option::None => -1,
    }
  };
  let _ = send(tx, 11);
  close(tx);
  let joined = join(worker);
  match joined {
    Option::Some(v) => out(`timeout parity join some {v}`),
    Option::None => out("timeout parity join none"),
    _ => out("timeout parity join other"),
  }
}

fn match_parity() {
  let maybe = Option::Some(3);
  match maybe {
    Option::Some(v) => out(`match some {v}`),
    Option::None => out("match none"),
  }
}

fn main() {
  out("no_std parity demo start");
  defer_probe();
  async_result_parity();
  async_try_parity();
  match_parity();
  timeout_parity();
  out("no_std parity demo done");
}
