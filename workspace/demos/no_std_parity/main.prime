//! no_std host parity demo.
//!
//! This module is designed to run both under a host runtime and under no_std
//! targets by defining local `Option`/`Result` types. It serves as a "probe
//! suite" to keep language/runtime behavior consistent across targets.
module demos::no_std_parity;

/// Minimal `Option` for no_std demos.
pub enum Option[T] {
  Some(T),
  None,
}

/// Minimal `Result` for no_std demos.
pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

/// Verifies `defer { ... };` runs exactly once at scope exit.
fn defer_probe() {
  let mut int32 guard = 0;
  defer {
    guard = guard + 1;
    out(`defer ran guard={guard}`);
  };
  out(`defer probe start guard={guard}`);
}

/// Checks that `spawn` + `join` produces an awaitable task on this target.
fn async_result_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v + 1,
      Option::None => -1,
    }
  };
  let _ = send(tx, 5);
  close(tx);

  let Task[int32] task = join(worker);
  let int32 value = await task;
  let _ = value;
  out("async result parity joined");
}

/// Uses `Result` inside an async task and validates `?`/matching behavior.
fn async_try_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => Result::Ok(v),
      Option::None => Result::Err("empty"),
    }
  };
  let _ = send(tx, 7);
  close(tx);

  let task = join(worker);
  let joined = await task;
  match joined {
    Result::Ok(v) => out(`async try parity ok {v}`),
    Result::Err(msg) => out(`async try parity err {msg}`),
    _ => out("async try parity other"),
  }
}

/// Demonstrates joining a task that returns an `Option`.
fn timeout_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    received
  };
  let _ = send(tx, 11);
  close(tx);

  let task = join(worker);
  let Option[int32] joined = await task;
  match joined {
    Option::Some(v) => out(`timeout parity join {v}`),
    Option::None => out("timeout parity none"),
    _ => out("timeout parity other"),
  }
}

/// Basic `match` on a locally defined enum.
fn match_parity() {
  let maybe = Option::Some(3);
  match maybe {
    Option::Some(v) => out(`match some {v}`),
    Option::None => out("match none"),
  }
}

/// Exercises cancellation and timeout primitives for async tasks.
///
/// These APIs are intended to be available in no_std as well:
/// - `await_timeout(task, ms)`
/// - `await_cancel(task, token)`
/// - `await_cancel_timeout(task, token, ms)`
fn cancellation_timeout_parity() {
  let (tx, rx) = channel[int32]();
  let task = recv_task(rx);
  let Result[Option[int32], string] timeout = await_timeout(task, 0);
  match timeout {
    Result::Err(msg) => out(`await_timeout parity err {msg}`),
    _ => out("await_timeout parity unexpected"),
  }

  let _ = tx;
  let (tx2, rx2) = channel[int32]();
  let CancelToken tok = cancel_token();
  let task2 = recv_task(rx2);
  cancel(tok);

  let Result[Option[int32], string] cancelled = await_cancel(task2, tok);
  match cancelled {
    Result::Err(msg) => out(`await_cancel parity err {msg}`),
    _ => out("await_cancel parity unexpected"),
  }

  let _ = tx2;
  let (tx3, rx3) = channel[int32]();
  let CancelToken tok3 = cancel_token();
  let task3 = recv_task(rx3);
  let Result[Option[int32], string] timeout2 = await_cancel_timeout(task3, tok3, 0);
  match timeout2 {
    Result::Err(msg) => out(`await_cancel_timeout parity err {msg}`),
    _ => out("await_cancel_timeout parity unexpected"),
  }

  let _ = tx3;
}

/// Runs the parity probes in sequence.
fn main() {
  out("no_std parity demo start");
  defer_probe();
  async_result_parity();
  async_try_parity();
  match_parity();
  timeout_parity();
  cancellation_timeout_parity();
  out("no_std parity demo done");
}
