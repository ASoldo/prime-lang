module demos::no_std_parity;

pub enum Option[T] {
  Some(T),
  None,
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn defer_probe() {
  let mut int32 guard = 0;
  defer {
  guard = guard + 1;
  out(`defer ran guard={guard}`);
};
  out(`defer probe start guard={guard}`);
}

fn async_result_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v + 1,
      Option::None => -1,
    }
  };
  let _ = send(tx, 5);
  close(tx);

  let Task[int32] task = join(worker);
  let int32 value = await task;
  let _ = value;
  out("async result parity joined");
}

fn async_try_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => Result::Ok(v),
      Option::None => Result::Err("empty"),
    }
  };
  let _ = send(tx, 7);
  close(tx);

  let task = join(worker);
  let joined = await task;
  match joined {
    Result::Ok(v) => out(`async try parity ok {v}`),
    Result::Err(msg) => out(`async try parity err {msg}`),
    _ => out("async try parity other"),
  }
}

fn timeout_parity() {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    received
  };
  let _ = send(tx, 11);
  close(tx);

  let task = join(worker);
  let Option[int32] joined = await task;
  match joined {
    Option::Some(v) => out(`timeout parity join {v}`),
    Option::None => out("timeout parity none"),
    _ => out("timeout parity other"),
  }
}

fn match_parity() {
  let maybe = Option::Some(3);
  match maybe {
    Option::Some(v) => out(`match some {v}`),
    Option::None => out("match none"),
  }
}

fn main() {
  out("no_std parity demo start");
  defer_probe();
  async_result_parity();
  async_try_parity();
  match_parity();
  timeout_parity();
  out("no_std parity demo done");
}
