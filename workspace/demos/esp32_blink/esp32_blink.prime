module demos::esp32_blink;

pub enum Option[T] {
  Some(T),
  None,
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn print_reset_reason(prefix: string, code: int32) {
  if code == 1 {
    out(`${prefix}{code} (POWERON_RESET)`);
  } else if code == 3 {
    out(`${prefix}{code} (SW_RESET)`);
  } else if code == 4 {
    out(`${prefix}{code} (OWDT_RESET)`);
  } else if code == 5 {
    out(`${prefix}{code} (DEEPSLEEP_RESET)`);
  } else if code == 6 {
    out(`${prefix}{code} (SDIO_RESET)`);
  } else if code == 7 {
    out(`${prefix}{code} (TG0WDT_RESET)`);
  } else if code == 8 {
    out(`${prefix}{code} (TG1WDT_RESET)`);
  } else if code == 9 {
    out(`${prefix}{code} (RTCWDT_SYS_RESET)`);
  } else if code == 10 {
    out(`${prefix}{code} (RTCWDT_RTC_RESET)`);
  } else if code == 11 {
    out(`${prefix}{code} (RTCWDT_CPU_RESET)`);
  } else if code == 12 {
    out(`${prefix}{code} (BROWNOUT_RESET)`);
  } else if code == 13 {
    out(`${prefix}{code} (RTCWDT_RTC_BOOT)`);
  } else if code == 14 {
    out(`${prefix}{code} (RTCWDT_VDDSDIO_RESET)`);
  } else {
    out(`${prefix}{code} (UNKNOWN_RESET)`);
  }
}

fn channel_demo() {
  out("channel demo: sending 42");

  let (tx, rx) = channel[int32]();
  let _ = send(tx, 42);
  match recv(rx) {
    Option::Some(v) => out(`channel recv: {v}`),
    Option::None => out("channel closed before recv"),
  }
  close(tx);
  close(rx);
}

fn ensure_pin(pin: int32) -> Result[int32, string] {
  if pin < 0 {
    Result::Err("pin must be >= 0")
  } else {
    Result::Ok(pin)
  }
}

fn drive_led(led: int32, level: int32) -> Result[(), string] {
  digital_write(led, level);
  Result::Ok(())
}

fn main() {
  let int32 my_var = 5;
  out(`hello from esp32 blink demo and value is {my_var}`);

  let int32 led = 2;
  let bool led_active_low = false;
  pin_mode(led, 1);
  out(`This is our second text {my_var}`);
  out("starting async blink demo on esp32 (no_std)");
  let int32 reason = reset_reason();
  print_reset_reason("reset reason: ", reason);

  let (probe_tx, probe_rx) = channel[int32]();
  let probe = spawn async {
    let Option[int32] received = await recv_task(probe_rx);
    match received {
      Option::Some(v) => out(`probe recv via spawn/join: {v}`),
      Option::None => out("probe channel closed before recv_task"),
    }
  };
  let _ = send(probe_tx, 99);
  close(probe_tx);
  join(probe);

  let blinker = async {
    let mut int32 counter = 0;
    let mut bool led_on = false;
    let int32 checked_led = ensure_pin(led)?;
    pin_mode(checked_led, 1);
    loop {
      let int32 on_level = if led_active_low {
        0
      } else {
        1
      };
      drive_led(checked_led, on_level)?;
      led_on = true;
      out(`async blink: LED ON (count {counter}, led_on {led_on})`);
      delay_ms(1000);
      if counter % 32 == 0 {
        channel_demo();
      }

      let int32 off_level = if led_active_low {
        1
      } else {
        0
      };
      drive_led(checked_led, off_level)?;
      led_on = false;
      out(`async blink: LED OFF (count {counter}, led_on {led_on})`);
      delay_ms(1000);
      if counter % 128 == 0 {
        let int32 cached = reset_reason();
        print_reset_reason("reset reason (cached): ", cached);
      }
      counter = counter + 1;
    }
    Result::Ok(())
  };
  match await blinker {
    Result::Ok(value) => {
      out(`value is {value}`);
    },
    Result::Err(msg) => out(`blink task error: {msg}`),
  }
}
