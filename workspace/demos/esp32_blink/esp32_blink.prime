module demos::esp32_blink;

pub enum Option[T] {
  Some(T),
  None,
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn print_reset_reason(prefix: string, code: int32) {
  if code == 1 {
    out(`${prefix}{code} (POWERON_RESET)`);
  } else if code == 3 {
    out(`${prefix}{code} (SW_RESET)`);
  } else if code == 4 {
    out(`${prefix}{code} (OWDT_RESET)`);
  } else if code == 5 {
    out(`${prefix}{code} (DEEPSLEEP_RESET)`);
  } else if code == 6 {
    out(`${prefix}{code} (SDIO_RESET)`);
  } else if code == 7 {
    out(`${prefix}{code} (TG0WDT_RESET)`);
  } else if code == 8 {
    out(`${prefix}{code} (TG1WDT_RESET)`);
  } else if code == 9 {
    out(`${prefix}{code} (RTCWDT_SYS_RESET)`);
  } else if code == 10 {
    out(`${prefix}{code} (RTCWDT_RTC_RESET)`);
  } else if code == 11 {
    out(`${prefix}{code} (RTCWDT_CPU_RESET)`);
  } else if code == 12 {
    out(`${prefix}{code} (BROWNOUT_RESET)`);
  } else if code == 13 {
    out(`${prefix}{code} (RTCWDT_RTC_BOOT)`);
  } else if code == 14 {
    out(`${prefix}{code} (RTCWDT_VDDSDIO_RESET)`);
  } else {
    out(`${prefix}{code} (UNKNOWN_RESET)`);
  }
}

fn channel_demo() {
  out("channel demo: sending 42");

  let (tx, rx) = channel[int32]();
  let _ = send(tx, 42);
  match recv(rx) {
    Option::Some(v) => out(`channel recv: {v}`),
    Option::None => out("channel closed before recv"),
  }
  close(tx);
  close(rx);
}

fn ensure_pin(pin: int32) -> Result[int32, string] {
  if pin < 0 {
    Result::Err("pin must be >= 0")
  } else {
    Result::Ok(pin)
  }
}

fn drive_led(led: int32, level: int32) -> Result[(), string] {
  digital_write(led, level);
  Result::Ok(())
}

fn async_result_probe() {
  let (tx, rx) = channel[Result[int32, string]]();
  let worker = spawn async {
    let Option[Result[int32, string]] received = await recv_task(rx);
    match received {
      Option::Some(res) => match res {
  Result::Ok(v) => Result::Ok(v + 1),
  Result::Err(msg) => Result::Err(msg),
},
      Option::None => Result::Err("closed"),
    }
  };
  let _ = send(tx, Result::Ok(7));
  close(tx);
  match join(worker) {
    Result::Ok(v) => out(`async result probe ok {v}`),
    Result::Err(msg) => out(`async result probe err {msg}`),
    _ => out("async result probe unexpected join"),
  }
  close(rx);
}

fn pool_reuse_sanity(iterations: int32) -> Result[(), string] {
  let mut int32 i = 0;
  while i < iterations {
    out(`pool reuse iter {i}: start`);

    let (tx, rx) = channel[int32]();
    let worker = spawn async {
      let Option[int32] received = await recv_task(rx);
      match received {
        Option::Some(v) => {
          out(`pool reuse worker: recv_task got Some({v})`);
          Result::Ok(v + 10)
        },
        Option::None => {
          out("pool reuse worker: recv_task got None");
          Result::Err("channel closed")
        },
      }
    };
    out(`pool reuse iter {i}: sending value`);

    let _ = send(tx, i);
    close(tx);

    let _ = join(worker);
    out(`pool reuse iter {i}: completed`);
    close(rx);
    i = i + 1;
  }
  Result::Ok(())
}

fn main() {
  let int32 my_var = 5;
  out(`hello from esp32 blink demo and value is {my_var}`);

  let int32 led = 2;
  let int32 button = 18;
  let bool button_active_low = true;
  let bool led_active_low = false;
  pin_mode(led, 1);
  pin_mode(button, 0);

  let int32 initial_button = digital_read(button);
  out(`button GPIO{button} initial read (raw {initial_button}, active_low {button_active_low})`);
  out("wire button: GPIO18 -> momentary switch -> GND (active-low)");
  out(`This is our second text {my_var}`);
  out("starting async blink demo on esp32 (no_std)");

  let int32 reason = reset_reason();
  print_reset_reason("reset reason: ", reason);
  async_result_probe();

  let _boot_logger = spawn async {
    let mut bool last_pressed = false;
    let mut int32 debounce = 0;
    let mut int32 heartbeat = 0;
    loop {
      let int32 raw = digital_read(button);
      let bool pressed = if button_active_low {
        raw == 0
      } else {
        raw != 0
      };
      if debounce > 0 {
        debounce = debounce - 1;
      }
      if last_pressed != pressed && debounce == 0 {
        if pressed {
          out(`button pressed (GPIO{button})`);
        } else {
          out(`button released (GPIO{button})`);
        }
        out(`button raw={raw} pressed={pressed}`);

        let int32 cached = reset_reason();
        print_reset_reason("reset reason (button): ", cached);
        debounce = 3;
      }
      last_pressed = pressed;
      if heartbeat % 40 == 0 {
        out(`button heartbeat: raw={raw} pressed={pressed}`);
      }
      heartbeat = heartbeat + 1;
      delay_ms(25);
    }
  };
  let _boot_probe = spawn async {
    let mut int32 i = 0;
    let mut int32 last = -99;
    loop {
      let int32 raw = digital_read(button);
      if raw != last {
        out(`boot probe raw change: {raw}`);
        last = raw;
      }
      if i % 10 == 0 {
        out(`boot probe sample {i}: raw={raw}`);
      }
      i = i + 1;
      if i > 50 {
        break;
      }
      delay_ms(100);
    }
  };
  let (probe_tx, probe_rx) = channel[int32]();
  let probe = spawn async {
    let Option[int32] received = await recv_task(probe_rx);
    match received {
      Option::Some(v) => out(`probe recv via spawn/join: {v}`),
      Option::None => out("probe channel closed before recv_task"),
    }
  };
  let _ = send(probe_tx, 99);
  close(probe_tx);
  join(probe);

  let _ = pool_reuse_sanity(1);
  let blinker = async {
    let mut int32 counter = 0;
    let mut bool led_on = false;
    let int32 checked_led = ensure_pin(led)?;
    pin_mode(checked_led, 1);
    loop {
      let int32 on_level = if led_active_low {
        0
      } else {
        1
      };
      drive_led(checked_led, on_level)?;
      led_on = true;
      out(`async blink: LED ON (count {counter}, led_on {led_on})`);
      delay_ms(1000);
      if counter % 128 == 0 {
        channel_demo();
      }
      if counter % 32 == 0 {
        let int32 btn_raw = digital_read(button);
        let bool btn_pressed = if button_active_low {
          btn_raw == 0
        } else {
          btn_raw != 0
        };
        out(`boot button sample in main loop: raw={btn_raw} pressed={btn_pressed}`);
      }

      let int32 off_level = if led_active_low {
        1
      } else {
        0
      };
      drive_led(checked_led, off_level)?;
      led_on = false;
      out(`async blink: LED OFF (count {counter}, led_on {led_on})`);
      delay_ms(1000);
      if counter % 256 == 0 {
        let int32 cached = reset_reason();
        print_reset_reason("reset reason (cached): ", cached);
      }
      counter = counter + 1;
    }
    Result::Ok(())
  };
  match await blinker {
    Result::Ok(value) => {
      out(`value is {value}`);
    },
    Result::Err(msg) => out(`blink task error: {msg}`),
    _ => out("blink task returned unknown result"),
  }
}
