module demos::esp32_blink;

pub enum Option[T] {
  Some(T),
  None,
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn channel_demo() {
  let (tx, rx) = channel[int32]();
  out("channel demo: sending 42");

  let _ = send(tx, 42);
  match recv(rx) {
    Option::Some(v) => out(`channel recv: {v}`),
    Option::None => out("channel closed before recv"),
  }
  close(tx);
}

fn main() {
  let int32 my_var = 5;
  out(`hello from esp32 blink demo and value is {my_var}`);

  let int32 led = 2;
  let bool led_active_low = false;
  pin_mode(led, 1);
  out(`This is our second text {my_var}`);
  out("starting async blink demo on esp32 (no_std)");

  let blinker = async {
    let mut int32 i = 0;
    loop {
      if i >= 6 {
        break;
      }

      let int32 on_level = if led_active_low {
        0
      } else {
        1
      };
      digital_write(led, on_level);
      out("async blink: LED ON");
      delay_ms(1000);
      channel_demo();

      let int32 off_level = if led_active_low {
        1
      } else {
        0
      };
      digital_write(led, off_level);
      out("async blink: LED OFF");
      delay_ms(1000);
      i = i + 1;
    }
  };
  await blinker;
  out("falling back to bare-metal blink loop");

  let int32 on_level = if led_active_low {
    0
  } else {
    1
  };
  let int32 off_level = if led_active_low {
    1
  } else {
    0
  };
  let mut int32 loops = 0;
  loop {
    digital_write(led, on_level);
    out("bare blink: LED ON");
    delay_ms(1000);
    digital_write(led, off_level);
    out("bare blink: LED OFF");
    delay_ms(1000);
    loops = loops + 1;
    if loops >= 600 {
      // Avoid log spam on very long runs.
      loops = 0;
      out("bare blink: still alive");
    }
  }
}
