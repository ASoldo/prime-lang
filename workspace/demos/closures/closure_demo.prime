module demos::closures;

fn apply_twice(f: fn(int32) -> int32, value: int32) -> int32 {
  f(f(value))
}

fn make_adder() -> fn(int32) -> int32 {
  let int32 base = 10;
  |x: int32| base + x
}

fn main() {
  let double = |x: int32| x * 2;
  let twice = apply_twice(double, 3);
  out(`apply_twice(double, 3) = {}`, twice);

  let add = make_adder();
  let sum = add(5);
  out(`make_adder()(5) = {}`, sum);

  let int32 shift = 7;
  let shifter = |y: int32| y + shift;
  out(`shifter(8) = {}`, shifter(8));

  let int32 a = 2;
  let int32 b = 3;
  let combine = |x: int32, y: int32| -> (int32, int32) {
    (x + a, y + b)
  };
  let (left, right) = combine(5, 6);
  out(`combine returns tuple ({}, {})`, left, right);

  let higher = |f: fn(int32) -> int32| -> fn(int32) -> int32 {
    |value: int32| f(value) + 1
  };
  let inc_after_double = higher(double);
  out(`higher-order closure on 4 = {}`, inc_after_double(4));

  let nested = |base: int32| -> fn(int32) -> int32 {
    let inner = |delta: int32| -> int32 {
      let bump = |z: int32| -> int32 {
        z + delta + base
      };
      bump(1)
    };
    inner
  };
  let inner_fn = nested(10);
  out(`nested closure result = {}`, inner_fn(5));

  let toggle = true;
  let flip = |value: bool| -> bool {
    if toggle {
      !value
    } else {
      value
    }
  };
  out(`flip(true) = {}`, flip(true));

  let suffix = "!";
  let shout = |_: int32| -> string {
    suffix
  };
  out(`shout(0) = {}`, shout(0));

  let bundle = (double, flip);
  let (use_double, use_flip) = bundle;
  out(`bundle.use_double(9) = {}`, use_double(9));
  out(`bundle.use_flip(false) = {}`, use_flip(false));

  let flag = false;
  let label = "ok";
  let status = |x: int32| -> (int32, bool, string) {
    (x + 1, flag, label)
  };
  let (num, active, text) = status(3);
  out(`status tuple = ({}, {}, {})`, num, active, text);

  let []int32 nums = [
    1,
    2,
  ];
  let Map[string, int32] scores = #{
    "a": 10,
  };
  let Box[int32] counter = box_new(5);
  let return_heap = |_: int32| -> ([]int32, Map[string, int32], Box[int32]) {
    (nums, scores, counter)
  };
  let (nums_rt, scores_rt, returned_box) = return_heap(0);
  let box_passthrough = |_: int32| -> Box[int32] {
    returned_box
  };
  let bp = box_passthrough(0);
  let []int32 nums_again = [
    1,
    2,
  ];
  let Map[string, int32] scores_again = #{
    "a": 10,
  };
  let nums_rt_len = nums_rt.len();
  let scores_rt_len = scores_rt.len();
  out("heap handles round-tripped through closures:");
  out(`lens -> nums_rt.len() = {}, scores_rt.len() = {}`, nums_rt_len, scores_rt_len);
  debug_show(nums_again);
  debug_show(scores_again);
  debug_show(bp);

  let mut []int32 captured_nums = [
    5,
  ];
  let mut Map[string, int32] captured_scores = #{
    "x": 1,
  };
  out("captured handles before closure:");
  debug_show(captured_nums);
  debug_show(captured_scores);

  captured_nums.push(6);
  captured_scores.insert("y", 2);
  out("captured handles after mutation:");
  debug_show(captured_nums.len());
  debug_show(captured_scores.len());
  let int32 ref_base = 11;
  let &int32 ref_alias = &ref_base;
  let show_ref = |_: int32| ref_alias;
  out(`reference capture returns {}`, show_ref(0));
}
