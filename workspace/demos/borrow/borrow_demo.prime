//! Borrowing and `&mut` examples.
//!
//! Focuses on how mutable borrows behave across control-flow boundaries:
//! `if`/`match`, loops, nested scopes, and destructuring.
module demos::borrow;

/// A small struct used for destructuring examples.
struct Refill {
  amount: int32;
}

/// Shows taking a mutable reference and using it to update a value.
fn alias_mut() {
  let mut int32 value = 10;
  let int32 copy = value;
  let &mut int32 first_ref = &mut value;
  *first_ref = copy + 5;
  let int32 final_value = *first_ref;
  out(`alias_mut copy {copy} final {}`, final_value);
}

/// Demonstrates that borrows created in `if`/`match` arms do not escape the arm.
fn if_and_match_merging(flag: bool) -> int32 {
  let mut int32 score = 1;
  if flag {
    let &mut int32 alias = &mut score;
    *alias = 2;
  } else {
    let &mut int32 alias = &mut score;
    *alias = 3;
  }
  {
    let &mut int32 after_if = &mut score;
    *after_if = *after_if + 1;
  }
  match flag {
    true => {
      let &mut int32 alias = &mut score;
      *alias = *alias + 1;
    },
    false => {
      let &mut int32 alias = &mut score;
      *alias = *alias + 2;
    },
  }
  score
}

/// Exercises borrow lifetimes through `while`, `while let`, and `for` loops.
fn loop_merging() -> int32 {
  let mut int32 total = 0;
  let mut int32 idx = 0;
  while idx < 2 {
    let &mut int32 alias = &mut total;
    *alias = *alias + idx;
    idx = idx + 1;
  }
  idx = 0;
  while let true = idx == 0 {
    let &mut int32 alias = &mut total;
    *alias = *alias + 5;
    idx = idx + 1;
  }
  for count in 0..2 {
    let &mut int32 alias = &mut total;
    *alias = *alias + count;
  }

  let []int32 entries = [
    3,
    4,
  ];
  for entry in entries {
    let &mut int32 alias = &mut total;
    *alias = *alias + entry;
  }
  total
}

/// Shows that borrows end at block boundaries and before `return` values.
fn nested_scope_and_return(flag: bool) -> int32 {
  let mut int32 depth = 0;
  {
    let &mut int32 alias = &mut depth;
    *alias = 7;
  }
  if flag {
    let &mut int32 alias = &mut depth;
    *alias = *alias + 1;
    depth
  }

  let &mut int32 final_ref = &mut depth;
  *final_ref = *final_ref + 2;
  depth
}

/// Pattern-destructuring with `mut` bindings for tuples, maps, and structs.
fn mutable_destructuring_examples() {
  let mut (int32, int32) pair = (5, 10);
  let mut (left, right) = pair;
  left = left + right;
  out(`tuple left {left} right {right} total {}`, left);

  let Map[string, int32] points = #{
    "hp": 20,
    "mp": 15,
  };
  let mut #{ "hp": hp, "mp": mp } = points;
  hp = hp + mp;
  out(`points hp {hp} mp {mp}`);

  let Refill refill = Refill{
    amount: 30,
  };
  let mut Refill{ amount: amount } = refill;
  amount = amount + 5;
  out(`refill amount -> {}`, amount);
}

/// Borrows a value through an inner block, then re-borrows it after the block.
fn borrow_through_block() {
  let mut int32 gauge = 12;
  {
    let &mut int32 block_ref = if gauge > 10 {
      &mut gauge
    } else {
      &mut gauge
    };
    *block_ref = *block_ref + 3;
    out(`block boosted to {}`, *block_ref);
  }

  let &mut int32 after_block = &mut gauge;
  *after_block = *after_block - 2;
  out(`after block gauge {gauge}`);
}

/// Runs each borrow example and prints the observed results.
fn main() {
  alias_mut();
  out(`if_and_match_merging(true) => {}`, if_and_match_merging(true));
  out(`if_and_match_merging(false) => {}`, if_and_match_merging(false));
  out(`loop_merging => {}`, loop_merging());
  out(`nested_scope_and_return(true) => {}`, nested_scope_and_return(true));
  out(`nested_scope_and_return(false) => {}`, nested_scope_and_return(false));
  mutable_destructuring_examples();
  borrow_through_block();

  let int32 my_var = 5;
  out(`hello {my_var}`);
}
