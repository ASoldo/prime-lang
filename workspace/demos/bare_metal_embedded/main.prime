module demos::bare_metal_embedded;

import core::types;

fn main() {
  out("bare metal demo starting");

  let []int32 readings = [
    1,
    2,
    3,
    4,
  ];
  let int32 total = sum(readings);
  out(`total = {total}`);

  let int32 threshold = 3;
  let []int32 filtered = filter_above(readings, threshold);
  out(`filtered count = {filtered.len()}`);

  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v,
      Option::None => -1,
    }
  };
  let _ = send(tx, total);
  close(tx);
  let int32 joined = join(worker);
  out(`spawn/join recv_task result = {joined}`);

  match parity_probe() {
    Result::Ok(v) => out(`parity probe ok: {v}`),
    Result::Err(msg) => out(`parity probe err: {msg}`),
  }
}

fn sum(values: []int32) -> int32 {
  let mut int32 acc = 0;
  for value in values {
    acc = acc + value;
  }
  acc
}

fn filter_above(values: []int32, threshold: int32) -> []int32 {
  let mut []int32 result = [];
  for value in values {
    if value > threshold {
      result.push(value);
    }
  }
  result
}

fn parity_probe() -> Result[int32, string] {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => Result::Ok(v * 2),
      Option::None => Result::Err("empty channel"),
    }
  };
  let _ = send(tx, 7);
  close(tx);
  join(worker)
}
