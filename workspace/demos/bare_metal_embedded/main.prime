//! Bare-metal style demo (no `core::types`).
//!
//! This file defines minimal `Option`/`Result` locally and exercises:
//! - slice transforms (`sum`, `filter_above`)
//! - channels + `spawn async { ... }` + `join(...)`
//! - async receive via `recv_task(...)`
//! - a small `recv_timeout(...)` probe
//!
//! Intended for embedded/no_std experimentation; the exact runtime bindings
//! depend on the target you compile for.
module demos::bare_metal_embedded;

/// Minimal `Option` for no_std demos.
pub enum Option[T] {
  Some(T),
  None,
}

/// Minimal `Result` for no_std demos.
pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

/// Runs a suite of simple "parity probes" used on embedded targets.
fn main() {
  out("bare metal demo starting");

  let []int32 readings = [
    1,
    2,
    3,
    4,
  ];
  let int32 total = sum(readings);
  out(`total = {total}`);

  let int32 threshold = 3;
  let []int32 filtered = filter_above(readings, threshold);
  out(`filtered count = {filtered.len()}`);

  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v,
      Option::None => -1,
    }
  };
  let _ = send(tx, total);
  close(tx);

  let _ = join(worker);
  out("spawn/join recv_task completed");
  out("starting parity_probe");
  match parity_probe() {
    Result::Ok(v) => out(`parity probe ok: {v}`),
    Result::Err(msg) => out(`parity probe err: {msg}`),
  }
  out("starting async_result_parity");
  async_result_parity();
  out("starting timeout_parity");
  timeout_parity();
}

/// Sums a slice of `int32`.
fn sum(values: []int32) -> int32 {
  let mut int32 acc = 0;
  for value in values {
    acc = acc + value;
  }
  acc
}

/// Filters values above `threshold` into a new slice.
fn filter_above(values: []int32, threshold: int32) -> []int32 {
  let mut []int32 result = [];
  for value in values {
    if value > threshold {
      result.push(value);
    }
  }
  result
}

/// Verifies that `spawn` + `recv_task` + `join` works with local `Result`.
fn parity_probe() -> Result[int32, string] {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => Result::Ok(v * 2),
      Option::None => Result::Err("empty channel"),
    }
  };
  let _ = send(tx, 7);
  close(tx);

  let joined = join(worker);
  match joined {
    Result::Ok(v) => Result::Ok(v),
    Result::Err(msg) => Result::Err(msg),
    Option::Some(v) => Result::Ok(v),
    Option::None => Result::Err("empty channel (join)"),
    _ => Result::Err("parity probe unexpected join value"),
  }
}

/// Exercises sending a `Result` through a channel and transforming it in a task.
fn async_result_parity() {
  let (tx, rx) = channel[Result[int32, string]]();
  let worker = spawn async {
    let Option[Result[int32, string]] received = await recv_task(rx);
    match received {
      Option::Some(res) => match res {
  Result::Ok(v) => Result::Ok(v + 1),
  Result::Err(msg) => Result::Err(msg),
},
      Option::None => Result::Err("closed"),
    }
  };
  let _ = send(tx, Result::Ok(5));
  close(tx);

  let _ = join(worker);
  out("async result parity joined");
}

/// Checks `recv_timeout(...)` behavior when no value is available.
fn timeout_parity() {
  let (tx, rx) = channel[int32]();
  let Option[int32] timed = recv_timeout(rx, 5);
  match timed {
    Option::Some(v) => out(`timeout parity got {v}`),
    Option::None => out("timeout parity none"),
  }
  close(tx);
  close(rx);
}
