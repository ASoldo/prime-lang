module demos::bare_metal_embedded;

pub enum Option[T] {
  Some(T),
  None,
}

pub enum Result[T, E] {
  Ok(T),
  Err(E),
}

fn main() {
  out("bare metal demo starting");

  let []int32 readings = [
    1,
    2,
    3,
    4,
  ];
  let int32 total = sum(readings);
  out(`total = {total}`);

  let int32 threshold = 3;
  let []int32 filtered = filter_above(readings, threshold);
  out(`filtered count = {filtered.len()}`);

  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => v,
      Option::None => -1,
    }
  };
  let _ = send(tx, total);
  close(tx);

  let _ = join(worker);
  out("spawn/join recv_task completed");
  out("starting parity_probe");
  match parity_probe() {
    Result::Ok(v) => out(`parity probe ok: {v}`),
    Result::Err(msg) => out(`parity probe err: {msg}`),
  }
  out("starting async_result_parity");
  async_result_parity();
  out("starting timeout_parity");
  timeout_parity();
}

fn sum(values: []int32) -> int32 {
  let mut int32 acc = 0;
  for value in values {
    acc = acc + value;
  }
  acc
}

fn filter_above(values: []int32, threshold: int32) -> []int32 {
  let mut []int32 result = [];
  for value in values {
    if value > threshold {
      result.push(value);
    }
  }
  result
}

fn parity_probe() -> Result[int32, string] {
  let (tx, rx) = channel[int32]();
  let worker = spawn async {
    let Option[int32] received = await recv_task(rx);
    match received {
      Option::Some(v) => Result::Ok(v * 2),
      Option::None => Result::Err("empty channel"),
    }
  };
  let _ = send(tx, 7);
  close(tx);

  let joined = join(worker);
  match joined {
    Result::Ok(v) => Result::Ok(v),
    Result::Err(msg) => Result::Err(msg),
    Option::Some(v) => Result::Ok(v),
    Option::None => Result::Err("empty channel (join)"),
    _ => Result::Err("parity probe unexpected join value"),
  }
}

fn async_result_parity() {
  let (tx, rx) = channel[Result[int32, string]]();
  let worker = spawn async {
    let Option[Result[int32, string]] received = await recv_task(rx);
    match received {
      Option::Some(res) => match res {
  Result::Ok(v) => Result::Ok(v + 1),
  Result::Err(msg) => Result::Err(msg),
},
      Option::None => Result::Err("closed"),
    }
  };
  let _ = send(tx, Result::Ok(5));
  close(tx);

  let _ = join(worker);
  out("async result parity joined");
}

fn timeout_parity() {
  let (tx, rx) = channel[int32]();
  let Option[int32] timed = recv_timeout(rx, 5);
  match timed {
    Option::Some(v) => out(`timeout parity got {v}`),
    Option::None => out("timeout parity none"),
  }
  close(tx);
  close(rx);
}
