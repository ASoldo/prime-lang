//! Error handling demo.
//!
//! Shows `Result[T, E]`, the `?` operator, and `try { ... }` expressions.
module demos::error_handling;

import core::types;

/// Validates `value` and returns an error when it is negative.
fn parse_energy(value: int32) -> Result[int32, string] {
  if value < 0 {
    Err("energy below zero")
  } else {
    Ok(value)
  }
}

/// Calls `parse_energy` and uses `?` to early-return on error.
fn apply_boost(value: int32) -> Result[int32, string] {
  let int32 parsed = parse_energy(value)?;
  if parsed % 2 == 0 {
    Ok(parsed * 2)
  } else {
    Err("boost requires even energy")
  }
}

/// Wraps `apply_boost` in a `try` expression, returning a `Result`.
fn calibrate_profile(value: int32) -> Result[int32, string] {
  try {
    let int32 boosted = apply_boost(value)?;
    boosted + 5
  }
}

/// Helper to print `Result` values.
fn log_result(label: string, outcome: Result[int32, string]) {
  match outcome {
    Ok(score) => out(`{label} => success {score}`),
    Err(message) => out(`{label} => error {message}`),
  }
}

/// Demonstrates early returns (including multi-value returns).
fn span_measurements(seed: int32) -> (int32, int32) {
  if seed < 0 {
    return 0, 0;
  }
  if seed > 100 && seed < 150 {
    return seed - 10, seed + 10;
  } else if seed >= 150 {
    return seed - 5, seed + 5;
  }

  let int32 midpoint = seed / 2;
  return midpoint - 5, midpoint + 5;
}

/// Runs the error-handling examples.
fn main() {
  out("=== error handling demo ===");
  log_result("stable", calibrate_profile(40));
  log_result("odd energy", calibrate_profile(35));
  log_result("overflow", calibrate_profile(140));
  out(`span sample => {}`, span_measurements(48));
  out(`clamped span => {}`, span_measurements(140));
}
