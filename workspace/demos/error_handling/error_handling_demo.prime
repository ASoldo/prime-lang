module demos.error_handling;

import core.types;

fn parse_energy(value: int32) -> Result[int32, string] {
  if value < 0 {
    Err("energy below zero")
  } else {
    Ok(value)
  }
}

fn apply_boost(value: int32) -> Result[int32, string] {
  let int32 parsed = parse_energy(value)?;
  if parsed % 2 == 0 {
    Ok(parsed * 2)
  } else {
    Err("boost requires even energy")
  }
}

fn calibrate_profile(value: int32) -> Result[int32, string] {
  try {
    let int32 boosted = apply_boost(value)?;
    boosted + 5
  }
}

fn log_result(label: string, outcome: Result[int32, string]) {
  match outcome {
    Ok(score) => out(`{label} => success {score}`),
    Err(message) => out(`{label} => error {message}`),
  }
}

fn span_measurements(seed: int32) -> (int32, int32) {
  if seed < 0 {
    return 0, 0;
  }
  if seed > 100 && seed < 150 {
    return seed - 10, seed + 10;
  } else if seed >= 150 {
    return seed - 5, seed + 5;
  }
  let int32 midpoint = seed / 2;
  return midpoint - 5, midpoint + 5;
}

fn main() {
  out("=== error handling demo ===");
  log_result("stable", calibrate_profile(40));
  log_result("odd energy", calibrate_profile(35));
  log_result("overflow", calibrate_profile(140));
  out(`span sample => {}`, span_measurements(48));
  out(`clamped span => {}`, span_measurements(140));
}
