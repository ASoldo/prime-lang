module demos::patterns;

import core::types;

struct Telemetry {
  hp: int32;
  mp: int32;
  notes: []string;
}

fn describe_reading(reading: (string, int32)) {
  match reading {
    ("temp", value) => out(value),
    ("status", code) => out(code),
    _ => out("unrecognized reading"),
  }
}

fn summarize_stats(stats: Map[string, int32]) {
  let #{ "hp": hp_total, "mp": mp_total } = stats;
  out("direct stats pair:");
  out(hp_total);
  out(mp_total);
  match stats {
    #{ "hp": hp, "mp": mp } => {
      out("stats ready");
      out(hp);
      out(mp);
    },
    _ => out("missing stats"),
  }
  if let Some(hp) = stats.get("hp") {
    out("hp present");
    out(hp);
  } else {
    out("no hp measurement");
  }
}

fn inspect_telemetry(data: Telemetry) {
  match data {
    Telemetry{ hp: hp, mp: mp, .. } => {
      out("telemetry summary");
      out(hp + mp);
    },
  }
  match data.notes {
    [first, ..rest] => {
      out("first note:");
      out(first);
      out(rest.len());
    },
    [] => out("no notes"),
  }
  let mut int32 idx = 0;
  while let Some(note) = data.notes.get(idx) {
    out("note entry:");
    out(note);
    idx = idx + 1;
  }
}

fn main() {
  describe_reading(("temp", 72));
  let Map[string, int32] stats = #{
    "hp": 120,
    "mp": 55,
  };

  summarize_stats(stats);
  let Telemetry snapshot = Telemetry{
    hp: 95,
    mp: 45,
    notes: ["stable", "ready"],
  };
  let Telemetry{ hp: base_hp, mp: base_mp, .. } = snapshot;
  out("snapshot sums:");
  out(base_hp + base_mp);

  inspect_telemetry(snapshot);
}
