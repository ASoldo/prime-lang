module demos::parallel_demo;

import core::types;

fn worker(id: int32, tx: Sender[int32], values: []int32) -> Result[(), string] {
  let mut int32 total = 0;
  for value in values {
    total = total + value;
  }
  send(tx, total + id)
}

fn main() {
  let (tx, rx) = channel[int32]();
  let []int32 left = [
    1,
    2,
    3,
    4,
  ];
  let []int32 right = [
    5,
    6,
    7,
    8,
  ];
  let JoinHandle[Result[(), string]] handle_left = spawn worker(100, tx, left);
  let JoinHandle[Result[(), string]] handle_right = spawn worker(200, tx, right);
  let mut int32 collected = 0;
  let mut int32 left_total = -1;
  let mut int32 right_total = -1;
  let mut int32 seen = 0;
  while let Some(value) = recv(rx) {
    collected = collected + value;
    if value > 200 {
      right_total = value;
    } else {
      left_total = value;
    }
    seen = seen + 1;
    if seen == 2 {
      break;
    }
  }
  close(rx);
  let Result[(), string] result_left = join(handle_left);
  if let Err(message) = &result_left {
    out(`left worker failed: {message}`);
    return;
  }
  let Result[(), string] result_right = join(handle_right);
  if let Err(message) = &result_right {
    out(`right worker failed: {message}`);
    return;
  }
  let bool left_ok = match result_left {
    Ok(_) => true,
    Err(message) => {
      out(`left worker returned error: {message}`);
      false
    },
    _ => {
      out("left worker returned unexpected value");
      false
    },
  };
  let bool right_ok = match result_right {
    Ok(_) => true,
    Err(message) => {
      out(`right worker returned error: {message}`);
      false
    },
    _ => {
      out("right worker returned unexpected value");
      false
    },
  };
  if !(left_ok && right_ok) {
    out("workers did not complete successfully");
    return;
  }
  out(`left total -> {left_total}`);
  out(`right total -> {right_total}`);
  out(`channel collected -> {collected}`);
}
